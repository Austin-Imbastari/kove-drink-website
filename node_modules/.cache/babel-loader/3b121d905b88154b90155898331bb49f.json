{"ast":null,"code":"import React, { useEffect, useState, useRef, useCallback, useMemo, useImperativeHandle } from 'react';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/**\r\n * Hook handles manually setting some additional attributes on the video that\r\n * can't be set directly via attributes on the element.\r\n *\r\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\r\n * @param {bool} muted - Whether the video should be muted\r\n * @param {number} volume - The volume level that the video's audio should be set to\r\n * @param {bool} disableRemotePlayback - Whether we want to disable showing controls to cast the video\r\n * @param {bool} disablePictureInPicture - Whether we want to disable showing controls to play the video in picture-in-picture mode\r\n */\n\n\nfunction useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture) {\n  useEffect(function () {\n    var videoElement = videoRef.current; // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n\n    videoElement.muted = muted; // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n\n    videoElement.volume = volume;\n  }, [videoRef, muted, volume]);\n  useEffect(function () {\n    var videoElement = videoRef.current; // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n    // via the video element's props, so we have to manually set them in an effect\n\n    videoElement.disableRemotePlayback = disableRemotePlayback;\n    videoElement.disablePictureInPicture = disablePictureInPicture;\n  }, [videoRef, disablePictureInPicture, disableRemotePlayback]);\n}\n/**\r\n * Hook adds event listeners to the hover target and returns whether the user is currently hovering over it or not.\r\n *\r\n * @param {HoverTarget} hoverTarget - Ref, function, or Node for the element that we should apply our hover event listeners to.\r\n *                                      If the user did not specify one with the hoverTarget prop, we will fall back to use\r\n *                                      the hover player's container div element.\r\n * @param {bool} disableDefaultEventHandling - Whether our default event handling should be disabled.\r\n * @param {func} onHoverStart - Callback fired when the user starts hovering on the player's hover target\r\n * @param {func} onHoverEnd - Callback fired when the user stops hovering on the player's hover target\r\n *\r\n * @returns {bool}  Whether the user is currently hovering over the player's hover target\r\n */\n\n\nfunction useIsHoveringOverVideo(hoverTarget, disableDefaultEventHandling, onHoverStartCallback, onHoverEndCallback) {\n  // Keep track of whether the user is hovering over the video and it should therefore be playing or not\n  var _a = useState(false),\n      isHoveringOverVideo = _a[0],\n      setIsHoveringOverVideo = _a[1];\n\n  var previousIsHoveringOverVideoRef = useRef(isHoveringOverVideo);\n  useEffect(function () {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined; // Get the element that we should add our hover event listeners to\n\n    var hoverEventTargetElement; // If the `hoverTarget` prop was provided, it could be a function, a DOM element, or a React ref, so\n    // figure out which one it is and get the hover target element out of it accordingly\n\n    if (typeof hoverTarget === 'function') {\n      hoverEventTargetElement = hoverTarget();\n    } else if (hoverTarget instanceof Node) {\n      hoverEventTargetElement = hoverTarget;\n    } else if (hoverTarget.current) {\n      hoverEventTargetElement = hoverTarget.current;\n    } // If we weren't able to get a valid hover target to attach event listeners to, return early\n\n\n    if (!hoverEventTargetElement || !hoverEventTargetElement.addEventListener) {\n      console.error('HoverVideoPlayer was unable to add event listeners to a hover target. Please check your usage of the `hoverTarget` prop.');\n      return undefined;\n    } // Add the event listeners\n\n\n    var onHoverStart = function () {\n      return setIsHoveringOverVideo(true);\n    };\n\n    var onHoverEnd = function () {\n      return setIsHoveringOverVideo(false);\n    }; // Mouse events\n\n\n    hoverEventTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverEventTargetElement.addEventListener('mouseleave', onHoverEnd); // Focus/blur\n\n    hoverEventTargetElement.addEventListener('focus', onHoverStart);\n    hoverEventTargetElement.addEventListener('blur', onHoverEnd); // Touch events\n\n    var touchStartListenerOptions = {\n      passive: true\n    };\n    hoverEventTargetElement.addEventListener('touchstart', onHoverStart, touchStartListenerOptions); // Event listener pauses the video when the user touches somewhere outside of the player\n\n    var onWindowTouchStart = function (event) {\n      if (!(event.target instanceof Node) || !hoverEventTargetElement.contains(event.target)) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener('touchstart', onWindowTouchStart, touchStartListenerOptions); // Return a cleanup function that removes all event listeners\n\n    return function () {\n      hoverEventTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverEventTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverEventTargetElement.removeEventListener('focus', onHoverStart);\n      hoverEventTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverEventTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTarget]); // Effect fires hover callbacks as isHoveringOverVideo changes\n\n  useEffect(function () {\n    if (previousIsHoveringOverVideoRef.current === isHoveringOverVideo) return;\n    previousIsHoveringOverVideoRef.current = isHoveringOverVideo;\n\n    if (isHoveringOverVideo && onHoverStartCallback != null) {\n      onHoverStartCallback();\n    } else if (!isHoveringOverVideo && onHoverEndCallback != null) {\n      onHoverEndCallback();\n    }\n  }, [isHoveringOverVideo, onHoverEndCallback, onHoverStartCallback]);\n  return isHoveringOverVideo;\n} // Enumerates states that the hover player's overlay can be in\n\n\nvar OverlayState;\n\n(function (OverlayState) {\n  // Only the paused overlay is visible, if provided\n  OverlayState[\"paused\"] = \"paused\"; // Both the paused and loading overlays are visible, if provided\n\n  OverlayState[\"loading\"] = \"loading\"; // No overlays are visible\n\n  OverlayState[\"playing\"] = \"playing\";\n})(OverlayState || (OverlayState = {}));\n/**\r\n * Hook manages safely transitioning video playback between\r\n * a playing or paused state, depending on the value of shouldPlayVideo\r\n *\r\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\r\n * @param {bool} shouldPlayVideo - Whether the video should currently be playing or not\r\n * @param {number} playbackRangeStart - The start time of the playback range that the video must be kept within\r\n * @param {number} playbackRangeEnd - The end time of the playback range that the video must be kept within\r\n * @param {bool} loop - Whether the video should loop when it reaches the end of its playback range or not\r\n *                        If a playback range is set, the native `loop` video attribute will not work, so we have to\r\n *                        manually implement this behavior ourselves.\r\n * @param {bool} restartOnPaused - Whether the video should be reset to the start when paused\r\n * @param {bool} shouldWaitForOverlayTransitionBeforePausing - Whether the player has an overlay which we should wait to fade back in before we pause the video\r\n * @param {bool} hasLoadingOverlay - Whether the player has an overlay to display when loading\r\n * @param {number} overlayTransitionDuration - How long it should take for overlays to fade in/out; this influences how long we should wait\r\n *                                              after the user stops hovering before fully pausing the video since the paused overlay needs time to fade in.\r\n * @param {number} loadingStateTimeout - How long to wait after starting a play attempt to fade in the loading overlay\r\n *\r\n * @returns {[OverlayState, bool]} An array with the current overlay state in the first position and whether the video player is active in the second positions\r\n */\n\n\nfunction useManageVideoPlayback(videoRef, shouldPlayVideo, playbackRangeStart, playbackRangeEnd, loop, restartOnPaused, shouldWaitForOverlayTransitionBeforePausing, hasLoadingOverlay, overlayTransitionDuration, loadingStateTimeout) {\n  // Keep track of how the paused and loading overlays should be displayed\n  var _a = useState(OverlayState.paused),\n      overlayState = _a[0],\n      setOverlayState = _a[1]; // Keep track of whether the video is currently playing or attempting to play\n\n\n  var _b = useState(false),\n      isVideoLoadingOrPlaying = _b[0],\n      setIsVideoLoadingOrPlaying = _b[1]; // Keep track of when the video is \"active\", meaning it is in one of the following states:\n  // 1. The user is hovering over the video but it is still loading\n  // 2. The user is hovering over the video and it is playing\n  // 3. The user is no longer hovering over the video but it is still transitioning back into a paused state\n  //\n  // This helps us keep track of when the player is truly done with the video so we can perform\n  // cleanup such as resetting the time to the start or unloading the video\n\n\n  var isVideoActive = shouldPlayVideo || isVideoLoadingOrPlaying; // Keep a ref for all variables related to the video's playback state\n  // which we need to persist between renders and manage asynchronously\n  // but shouldn't trigger re-renders when updated\n\n  var mutableVideoState = useRef(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      // Whether there is a play promise in progress which we should avoid interrupting\n      // with calls to video.pause() or video.load()\n      isPlayAttemptInProgress: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: playbackRangeStart || 0,\n      // Keep refs to previous values for some states so we can avoid running effects for\n      // changes in values we don't care about\n      previousIsVideoActive: false,\n      previousShouldPlayVideo: false\n    };\n  } // Cancel any pending timeouts to pause or show a loading state\n\n\n  var clearVideoStateTimeouts = useCallback(function () {\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n  }, []);\n  useEffect( // On cleanup when the component is unmounting, clear any outstanding timeouts\n  function () {\n    return function () {\n      return clearVideoStateTimeouts();\n    };\n  }, [clearVideoStateTimeouts]); // Method begins an attempt to play the video and updates state accordingly\n\n  var attemptToPlayVideo = useCallback(function () {\n    mutableVideoState.current.isPlayAttemptInProgress = true;\n    var videoElement = videoRef.current;\n    videoElement.play().catch(function (error) {\n      // Additional handling for when browsers block playback for unmuted videos.\n      // This is unfortunately necessary because most modern browsers do not allow playing videos with audio\n      //  until the user has \"interacted\" with the page by clicking somewhere at least once; mouseenter events\n      //  don't count.\n      // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked\n      // playing the video because the user hasn't clicked anywhere on the page yet.\n      if (!videoElement.muted && error.name === 'NotAllowedError') {\n        console.warn('HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.'); // Mute the video and attempt to play again\n\n        videoElement.muted = true;\n        videoElement.play(); // When the user clicks on the document, unmute the video since we should now\n        // be free to play audio\n\n        var onClickDocument_1 = function () {\n          videoElement.muted = false; // Clean up the event listener so it is only fired once\n\n          document.removeEventListener('click', onClickDocument_1);\n        };\n\n        document.addEventListener('click', onClickDocument_1);\n      } else {\n        // Log any other playback errors with console.error\n        console.error(\"HoverVideoPlayer: \" + error.message);\n      }\n    });\n  }, [videoRef]); // Method attempts to pause the video, if it is safe to do so without interrupting a pending play promise\n\n  var attemptToPauseVideo = useCallback(function () {\n    var videoElement = videoRef.current;\n\n    if (!videoElement.paused && // If there is a play attempt in progress, the video can't be\n    //  safely paused right away without intnerrupting the play promise and throwing an error.\n    // In this case, we'll have to wait for the logic in the video's `onPlaying` event\n    // to immediately pause the video as soon as the play promise resolves\n    !mutableVideoState.current.isPlayAttemptInProgress) {\n      videoElement.pause();\n    }\n  }, [videoRef]); // Effect adds a `play` and `pause` event listener to the video element to keep our state\n  // updated to reflect whether the video is currently playing or paused\n\n  useEffect(function () {\n    var videoElement = videoRef.current;\n\n    var onPause = function () {\n      return setIsVideoLoadingOrPlaying(false);\n    };\n\n    var onPlay = function () {\n      return setIsVideoLoadingOrPlaying(true);\n    };\n\n    videoElement.addEventListener('pause', onPause);\n    videoElement.addEventListener('play', onPlay);\n    return function () {\n      videoElement.removeEventListener('pause', onPause);\n      videoElement.removeEventListener('play', onPlay);\n    };\n  }, [videoRef]); // Effect adds a `playing` event listener to the video to update state to reflect when the video successfully starts playing\n\n  useEffect(function () {\n    var videoElement = videoRef.current; // Listen for when the video actually finishes loading and starts playing\n\n    var onPlaying = function () {\n      // Ensure we cancel any pending loading state timeout\n      clearVideoStateTimeouts(); // The play attempt is now complete\n\n      mutableVideoState.current.isPlayAttemptInProgress = false;\n\n      if (shouldPlayVideo) {\n        // Hide the overlays to reveal the video now that it's playing\n        setOverlayState(OverlayState.playing);\n      } else {\n        // If the play attempt just succeeded but we no longer want to play the video,\n        // pause it immediately!\n        videoElement.pause();\n      }\n    };\n\n    videoElement.addEventListener('playing', onPlaying);\n    return function () {\n      videoElement.removeEventListener('playing', onPlaying);\n    };\n  }, [clearVideoStateTimeouts, shouldPlayVideo, videoRef]); // When the video becomes inactive, effect resets it to the start if restartOnPaused is true and\n  // stores the video's current time so we can restore to it when we start playing the video again\n\n  useEffect(function () {\n    if (mutableVideoState.current.previousIsVideoActive === isVideoActive) {\n      return;\n    }\n\n    mutableVideoState.current.previousIsVideoActive = isVideoActive;\n\n    if (!isVideoActive) {\n      var videoElement = videoRef.current; // Ensure we cancel any pending timeouts to pause or show a loading state\n      // since we are now officially paused\n\n      clearVideoStateTimeouts();\n\n      if (restartOnPaused) {\n        // Reset the video to the start since we're now paused\n        var resetStartTime = playbackRangeStart || 0;\n        videoElement.currentTime = resetStartTime;\n      } // Hang onto the time that the video is currently at so we can\n      // restore it when we try to play again\n      // This is mainly helpful because the unloadVideoOnPaused prop will cause\n      // the video's currentTime to be cleared every time its sources are unloaded\n      // after pausing\n\n\n      mutableVideoState.current.videoTimeToRestore = videoElement.currentTime;\n    }\n  }, [clearVideoStateTimeouts, isVideoActive, playbackRangeStart, restartOnPaused, videoRef]); // Effect starts an update loop while the video is playing\n  // to ensure the video stays within the bounds of its playback range\n\n  useEffect(function () {\n    if ( // If we don't have a playback range set, we don't need to do anything here\n    playbackRangeStart === null && playbackRangeEnd === null) return undefined;\n    var videoElement = videoRef.current; // Checks the video's time to make sure it\n    // stays clamped inside the playback range\n\n    var keepVideoTimeWithinPlaybackRange = function () {\n      // Use playbackRangeEnd as our maximum time to play to, or default to the video's full duration\n      var playbackRangeMaxTime = playbackRangeEnd || videoElement.duration; // Use playbackRangeStart as our minimum time to play from, or default to the very beginning of the video (0sƒ)\n\n      var playbackRangeMinTime = playbackRangeStart || 0;\n\n      if (videoElement.currentTime >= playbackRangeMaxTime) {\n        // If the video's current time has played past the maximum time in the playback range,\n        // determine how to handle keeping the video inside of the playback range\n        if (loop) {\n          // If the video should loop, jump it back to the start of the playback range again\n          videoElement.currentTime = playbackRangeMinTime; // If the video is paused, start playing it again (when the video reaches the end\n          // of the playback range for the first time, most browsers will pause it)\n\n          if (shouldPlayVideo && (videoElement.paused || videoElement.ended)) {\n            attemptToPlayVideo();\n          }\n        } else {\n          // If we don't want to loop the video, just pause it\n          attemptToPauseVideo();\n\n          if (videoElement.currentTime > playbackRangeMaxTime) {\n            videoElement.currentTime = playbackRangeMaxTime;\n          }\n        }\n      } else if (videoElement.currentTime < playbackRangeMinTime) {\n        // If the video's current time has someone gotten before the playback range,\n        // clamp it to the lower end of the playback range\n        videoElement.currentTime = playbackRangeMinTime;\n      }\n    }; // Run one initial check to make sure the video is initially clamped within its playback range\n\n\n    keepVideoTimeWithinPlaybackRange(); // Add a timeupdate event listener to keep the video within its playback range\n    // as its time changes\n\n    videoElement.addEventListener('timeupdate', keepVideoTimeWithinPlaybackRange); // Remove the event listener on cleanup\n\n    return function () {\n      return videoElement.removeEventListener('timeupdate', keepVideoTimeWithinPlaybackRange);\n    };\n  }, [attemptToPauseVideo, attemptToPlayVideo, loop, playbackRangeEnd, playbackRangeStart, shouldPlayVideo, videoRef]); // Effect attempts to play or pause the video as shouldPlayVideo changes\n\n  useEffect(function () {\n    // Only run the effect when shouldPlayVideo changes\n    if (mutableVideoState.current.previousShouldPlayVideo === shouldPlayVideo) {\n      return;\n    }\n\n    mutableVideoState.current.previousShouldPlayVideo = shouldPlayVideo; // Clear any outstanding timeouts since our playback state is changing\n\n    clearVideoStateTimeouts();\n    var videoElement = videoRef.current; // The video is stopped if it is paused or ended\n\n    var isVideoStopped = videoElement.paused || videoElement.ended; // If shouldPlayVideo is true, attempt to start playing the video\n\n    if (shouldPlayVideo) {\n      // readyState 3 is HAVE_FUTURE_DATA, meaning the video has loaded enough data that it can play\n      var isVideoLoadedEnoughToPlay = videoElement.readyState >= 3; // If the video is stopped or still loading and we have a loading overlay,\n      // set a timeout to display the overlay if the video doesn't finish loading\n      // after a certain amount of time\n\n      if ((isVideoStopped || !isVideoLoadedEnoughToPlay) && hasLoadingOverlay) {\n        // If we have a loading overlay, set a timeout to start showing it if the video doesn't start playing\n        // before the loading state timeout has elapsed\n        mutableVideoState.current.loadingStateTimeout = window.setTimeout(function () {\n          // If this timeout wasn't cancelled, we're still trying to play the video\n          // and it's still loading, so fade in the loading overlay\n          setOverlayState(OverlayState.loading);\n        }, loadingStateTimeout);\n      } // If the video is fully stopped, we need to attempt to start it by calling play()\n\n\n      if (isVideoStopped) {\n        // Ensure we're at the correct time to start playing from\n        videoElement.currentTime = mutableVideoState.current.videoTimeToRestore; // Start attempting to play\n\n        attemptToPlayVideo();\n      } else if (isVideoLoadedEnoughToPlay) {\n        // If the video isn't stopped and is loaded enough to play. it's already playing,\n        // so ensure the overlays are hidden to reflect that!\n        setOverlayState(OverlayState.playing);\n      }\n    } // Otherwise if shouldPlayVideo is false, go through the process necessary to pause the video\n    else {\n      // Start fading the paused overlay back in\n      setOverlayState(OverlayState.paused);\n\n      if (shouldWaitForOverlayTransitionBeforePausing && overlayTransitionDuration) {\n        // If we have a paused/hover overlay, set a timeout with a duration of the overlay's fade\n        // transition since we want to keep the video playing until the overlay has fully\n        // faded in and hidden it.\n        mutableVideoState.current.pauseTimeout = window.setTimeout(attemptToPauseVideo, overlayTransitionDuration);\n      } else {\n        // If we don't have an overlay transition to wait on, pause right away!\n        attemptToPauseVideo();\n      }\n    }\n  }, [attemptToPauseVideo, attemptToPlayVideo, clearVideoStateTimeouts, hasLoadingOverlay, shouldWaitForOverlayTransitionBeforePausing, loadingStateTimeout, overlayTransitionDuration, shouldPlayVideo, videoRef]);\n  return [overlayState, isVideoActive];\n}\n/**\r\n * Hook unloads the video when it is paused, if the unloadVideoOnPaused prop was set to true\r\n *\r\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\r\n * @param {bool} shouldUnloadVideo - Whether we should unload the video's sources\r\n */\n\n\nfunction useUnloadVideo(videoRef, shouldUnloadVideo) {\n  // Effect ensures the video element fully unloads after its <source> tags were removed\n  useEffect(function () {\n    if (shouldUnloadVideo) {\n      // Perform a manual load to unload the video's current source\n      var videoElement = videoRef.current;\n      videoElement.load();\n    }\n  }, [shouldUnloadVideo, videoRef]);\n}\n/**\r\n * @function  formatVideoSrc\r\n *\r\n * Hook takes the videoSrc prop and formats it as a standardized array of VideoSource objects which can be used to render\r\n * <source> elements for the video\r\n *\r\n * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.\r\n * @param {number}  playbackRangeStart - The earliest time in seconds that we should start loading the video from.\r\n *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only\r\n *                                        load the video starting from this time.\r\n *                                        If not provided, we will load from the start of the video.\r\n * @param {number}  playbackRangeEnd - The maximum time in seconds that we should load the video to.\r\n *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only\r\n *                                        load the video up to this time.\r\n *                                        If not provided, we will load to the end of the video.\r\n *\r\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\r\n */\n\n\nfunction useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd) {\n  return useMemo(function () {\n    var formattedVideoSources = [];\n\n    if (videoSrc == null) {\n      // A videoSrc value is required in order to make the video player work\n      console.error(\"Error: 'videoSrc' prop is required for HoverVideoPlayer component\");\n    } else {\n      // Make sure we can treat the videoSrc value as an array\n      var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc]; // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n\n      for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {\n        var source = rawVideoSources[i];\n        var hasPlaybackRangeStart = playbackRangeStart !== null;\n        var hasPlaybackRangeEnd = playbackRangeEnd !== null; // Construct a media fragment identifier string to append to the video's URL to ensure\n        // we only load the portion of the video that we need for the provided playback range\n        // (see here for more details: https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery#specifying_playback_range)\n\n        var playbackRangeMediaFragmentIdentifier = hasPlaybackRangeStart || hasPlaybackRangeEnd ? // If we have a playback range defined, construct a #t media fragment identifier string\n        // This identifier follows the format `#t=[starttime][,endtime]` and will tell the browser to only load the video file\n        // within this defined time range.\n        // This helps save us from loading some unneeded data when we only need whatever is within the playback range!\n        \"#t=\" + (hasPlaybackRangeStart ? playbackRangeStart : '') + (hasPlaybackRangeEnd ? \",\" + playbackRangeEnd : '') : '';\n\n        if (typeof source === 'string') {\n          // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n          formattedVideoSources.push({\n            src: \"\" + source + playbackRangeMediaFragmentIdentifier\n          });\n        } else if (source && source.src) {\n          // If the source is an object with an src, just add it to the array\n          formattedVideoSources.push({\n            src: \"\" + source.src + playbackRangeMediaFragmentIdentifier,\n            type: source.type\n          });\n        } else {\n          // Log an error if one of the videoSrc values is invalid\n          console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\", source);\n        }\n      }\n    }\n\n    return formattedVideoSources;\n  }, [videoSrc, playbackRangeStart, playbackRangeEnd]);\n}\n/**\r\n * Hook takes the videoCaptions prop and formats it as a standardized array of VideoCaptionsTrack objects which can be used to render\r\n * <track> elements for the video\r\n *\r\n * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.\r\n *\r\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\r\n */\n\n\nfunction useFormatVideoCaptions(videoCaptions) {\n  return useMemo(function () {\n    var formattedVideoCaptions = []; // If captions were provided, format them for use for the video\n\n    if (videoCaptions != null) {\n      // Make sure we can treat the videoCaptions value as an array\n      var rawVideoCaptions = Array.isArray(videoCaptions) ? videoCaptions : [videoCaptions]; // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n      // objects that can be used to render caption tracks for the video\n\n      for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {\n        var captions = rawVideoCaptions[i];\n\n        if (captions && captions.src) {\n          formattedVideoCaptions.push({\n            src: captions.src,\n            srcLang: captions.srcLang,\n            label: captions.label,\n            kind: captions.kind || 'captions',\n            default: Boolean(captions.default)\n          });\n        } else {\n          // Log an error if one of the videoCaptions values is invalid\n          console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\", captions);\n        }\n      }\n    }\n\n    return formattedVideoCaptions;\n  }, [videoCaptions]);\n} // CSS styles to make some contents in the player expand to fill the container\n\n\nvar expandToFillContainerStyle = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0\n};\nvar containerMatchContentDimensionsStyle = {\n  display: 'inline-block'\n};\nvar containerSizingStyles = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null\n}; // Styles to apply to the paused overlay wrapper for each sizing mode\n\nvar pausedOverlayWrapperSizingStyles = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative'\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null\n}; // Styles to apply to the video element for each sizing mode\n\nvar videoSizingStyles = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%'\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null\n};\n/**\r\n * @component HoverVideoPlayer\r\n * @license MIT\r\n *\r\n * @param {HoverVideoPlayerProps} props\r\n */\n\nvar HoverVideoPlayer = function (_a) {\n  var videoSrc = _a.videoSrc,\n      _b = _a.videoCaptions,\n      videoCaptions = _b === void 0 ? null : _b,\n      _c = _a.focused,\n      focused = _c === void 0 ? false : _c,\n      _d = _a.disableDefaultEventHandling,\n      disableDefaultEventHandling = _d === void 0 ? false : _d,\n      _e = _a.hoverTarget,\n      hoverTarget = _e === void 0 ? null : _e,\n      _f = _a.onHoverStart,\n      onHoverStart = _f === void 0 ? null : _f,\n      _g = _a.onHoverEnd,\n      onHoverEnd = _g === void 0 ? null : _g,\n      _h = _a.hoverOverlay,\n      hoverOverlay = _h === void 0 ? null : _h,\n      _j = _a.pausedOverlay,\n      pausedOverlay = _j === void 0 ? null : _j,\n      _k = _a.loadingOverlay,\n      loadingOverlay = _k === void 0 ? null : _k,\n      _l = _a.loadingStateTimeout,\n      loadingStateTimeout = _l === void 0 ? 200 : _l,\n      _m = _a.overlayTransitionDuration,\n      overlayTransitionDuration = _m === void 0 ? 400 : _m,\n      _o = _a.restartOnPaused,\n      restartOnPaused = _o === void 0 ? false : _o,\n      _p = _a.unloadVideoOnPaused,\n      unloadVideoOnPaused = _p === void 0 ? false : _p,\n      _q = _a.playbackRangeStart,\n      playbackRangeStart = _q === void 0 ? null : _q,\n      _r = _a.playbackRangeEnd,\n      playbackRangeEnd = _r === void 0 ? null : _r,\n      _s = _a.muted,\n      muted = _s === void 0 ? true : _s,\n      _t = _a.volume,\n      volume = _t === void 0 ? 1 : _t,\n      _u = _a.loop,\n      loop = _u === void 0 ? true : _u,\n      _v = _a.preload,\n      preload = _v === void 0 ? null : _v,\n      _w = _a.crossOrigin,\n      crossOrigin = _w === void 0 ? 'anonymous' : _w,\n      _x = _a.controls,\n      controls = _x === void 0 ? false : _x,\n      _y = _a.controlsList,\n      controlsList = _y === void 0 ? null : _y,\n      _z = _a.disableRemotePlayback,\n      disableRemotePlayback = _z === void 0 ? true : _z,\n      _0 = _a.disablePictureInPicture,\n      disablePictureInPicture = _0 === void 0 ? true : _0,\n      _1 = _a.className,\n      className = _1 === void 0 ? null : _1,\n      _2 = _a.style,\n      style = _2 === void 0 ? null : _2,\n      _3 = _a.hoverOverlayWrapperClassName,\n      hoverOverlayWrapperClassName = _3 === void 0 ? null : _3,\n      _4 = _a.hoverOverlayWrapperStyle,\n      hoverOverlayWrapperStyle = _4 === void 0 ? null : _4,\n      _5 = _a.pausedOverlayWrapperClassName,\n      pausedOverlayWrapperClassName = _5 === void 0 ? null : _5,\n      _6 = _a.pausedOverlayWrapperStyle,\n      pausedOverlayWrapperStyle = _6 === void 0 ? null : _6,\n      _7 = _a.loadingOverlayWrapperClassName,\n      loadingOverlayWrapperClassName = _7 === void 0 ? null : _7,\n      _8 = _a.loadingOverlayWrapperStyle,\n      loadingOverlayWrapperStyle = _8 === void 0 ? null : _8,\n      _9 = _a.videoId,\n      videoId = _9 === void 0 ? null : _9,\n      _10 = _a.videoClassName,\n      videoClassName = _10 === void 0 ? null : _10,\n      _11 = _a.videoRef,\n      forwardedVideoRef = _11 === void 0 ? null : _11,\n      _12 = _a.videoStyle,\n      videoStyle = _12 === void 0 ? null : _12,\n      _13 = _a.sizingMode,\n      sizingMode = _13 === void 0 ? 'video' : _13; // Element refs\n\n  var containerRef = useRef(null);\n  var videoRef = useRef(null); // Forward out local videoRef along to the videoRef prop\n\n  useImperativeHandle(forwardedVideoRef, function () {\n    return videoRef.current;\n  }); // Effect sets attributes on the video which can't be done via props\n\n  useSetAdditionalAttributesOnVideo(videoRef, muted, volume, disableRemotePlayback, disablePictureInPicture);\n  var isHoveringOverVideo = useIsHoveringOverVideo( // If the hoverTarget prop wasn't provided, fall back to the component's container div\n  hoverTarget || containerRef, disableDefaultEventHandling, onHoverStart, onHoverEnd); // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled\n\n  var shouldPlayVideo = isHoveringOverVideo || focused;\n  var hasPausedOverlay = Boolean(pausedOverlay);\n  var hasHoverOverlay = Boolean(hoverOverlay); // If we have a paused or hover overlay, the player should wait\n  // for the overlay(s) to finish transitioning back in before we\n  // pause the video\n\n  var shouldWaitForOverlayTransitionBeforePausing = hasPausedOverlay || hasHoverOverlay;\n  var hasLoadingOverlay = Boolean(loadingOverlay); // Effect handles transitioning the video between playing or paused states\n  // depending on the current value for `shouldPlayVideo`\n\n  var _14 = useManageVideoPlayback(videoRef, shouldPlayVideo, playbackRangeStart, playbackRangeEnd, loop, restartOnPaused, shouldWaitForOverlayTransitionBeforePausing, hasLoadingOverlay, overlayTransitionDuration, loadingStateTimeout),\n      overlayState = _14[0],\n      isVideoActive = _14[1]; // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.\n  // We will remove the video's <source> tags in this render and then call video.load() in an effect to\n  // fully unload the video\n\n\n  var shouldUnloadVideo = unloadVideoOnPaused && !isVideoActive;\n  useUnloadVideo(videoRef, shouldUnloadVideo); // Parse the sources and captions into formatted arrays that we can use to\n  // render <source> and <track> elements for the video\n\n  var formattedVideoSources = useFormatVideoSrc(videoSrc, playbackRangeStart, playbackRangeEnd);\n  var formattedVideoCaptions = useFormatVideoCaptions(videoCaptions);\n  var hasPlaybackRange = playbackRangeStart !== null || playbackRangeEnd !== null; // Show the paused overlay if the overlay state is either \"paused\" OR \"loading\"; if\n  // \"loading\", the loading overlay will be displayed on top of the paused overlay\n\n  var isPausedOverlayVisible = overlayState !== OverlayState.playing; // Show the loading overlay only if the overlay state is specifically \"loading\"\n\n  var isLoadingOverlayVisibile = overlayState === OverlayState.loading;\n  return React.createElement(\"div\", {\n    \"data-testid\": \"hover-video-player-container\",\n    ref: containerRef,\n    className: className,\n    style: __assign(__assign(__assign({}, containerSizingStyles[sizingMode]), {\n      position: 'relative'\n    }), style)\n  }, hasPausedOverlay ? React.createElement(\"div\", {\n    style: __assign(__assign(__assign({}, pausedOverlayWrapperSizingStyles[sizingMode]), {\n      zIndex: 1,\n      opacity: isPausedOverlayVisible ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\",\n      // Disable pointer events on the paused overlay when it's hidden\n      pointerEvents: isPausedOverlayVisible ? 'auto' : 'none'\n    }), pausedOverlayWrapperStyle),\n    className: pausedOverlayWrapperClassName,\n    \"data-testid\": \"paused-overlay-wrapper\"\n  }, pausedOverlay) : null, hasLoadingOverlay ? React.createElement(\"div\", {\n    style: __assign(__assign(__assign({}, expandToFillContainerStyle), {\n      zIndex: 2,\n      opacity: isLoadingOverlayVisibile ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\",\n      // Disable pointer events on the loading overlay when it's hidden\n      pointerEvents: isLoadingOverlayVisibile ? 'auto' : 'none'\n    }), loadingOverlayWrapperStyle),\n    className: loadingOverlayWrapperClassName,\n    \"data-testid\": \"loading-overlay-wrapper\"\n  }, loadingOverlay) : null, hasHoverOverlay ? React.createElement(\"div\", {\n    style: __assign(__assign(__assign({}, expandToFillContainerStyle), {\n      zIndex: 3,\n      // Show the hover overlay when the player is hovered/playing\n      opacity: shouldPlayVideo ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\",\n      // Disable pointer events on the hover overlay when it's hidden\n      pointerEvents: shouldPlayVideo ? 'auto' : 'none'\n    }), hoverOverlayWrapperStyle),\n    className: hoverOverlayWrapperClassName,\n    \"data-testid\": \"hover-overlay-wrapper\"\n  }, hoverOverlay) : null, React.createElement(\"video\", {\n    // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;\n    // in that case, we will manually implement this behavior\n    loop: loop && !hasPlaybackRange,\n    playsInline: true,\n    preload: preload,\n    crossOrigin: crossOrigin,\n    ref: videoRef,\n    style: __assign(__assign(__assign({}, videoSizingStyles[sizingMode]), {\n      objectFit: 'cover'\n    }), videoStyle),\n    controls: controls,\n    controlsList: controlsList,\n    className: videoClassName,\n    id: videoId,\n    \"data-testid\": \"video-element\"\n  }, !shouldUnloadVideo && // Only render sources for the video if it is not unloaded\n  formattedVideoSources.map(function (_a) {\n    var src = _a.src,\n        type = _a.type;\n    return React.createElement(\"source\", {\n      key: src,\n      src: src,\n      type: type\n    });\n  }), formattedVideoCaptions.map(function (_a) {\n    var src = _a.src,\n        srcLang = _a.srcLang,\n        label = _a.label,\n        kind = _a.kind,\n        isDefault = _a.default;\n    return React.createElement(\"track\", {\n      key: src,\n      kind: kind,\n      src: src,\n      srcLang: srcLang,\n      label: label,\n      default: isDefault\n    });\n  })));\n};\n\nexport { HoverVideoPlayer as default };","map":{"version":3,"mappings":"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","names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","useSetAdditionalAttributesOnVideo","videoRef","muted","volume","disableRemotePlayback","disablePictureInPicture","useEffect","videoElement","current","useIsHoveringOverVideo","hoverTarget","disableDefaultEventHandling","onHoverStartCallback","onHoverEndCallback","useState","isHoveringOverVideo","setIsHoveringOverVideo","previousIsHoveringOverVideoRef","useRef","undefined","hoverEventTargetElement","Node","addEventListener","console","error","onHoverStart","onHoverEnd","touchStartListenerOptions","passive","onWindowTouchStart","event","target","contains","window","removeEventListener","OverlayState","useManageVideoPlayback","shouldPlayVideo","playbackRangeStart","playbackRangeEnd","loop","restartOnPaused","shouldWaitForOverlayTransitionBeforePausing","hasLoadingOverlay","overlayTransitionDuration","loadingStateTimeout","paused","overlayState","setOverlayState","isVideoLoadingOrPlaying","setIsVideoLoadingOrPlaying","isVideoActive","mutableVideoState","isPlayAttemptInProgress","pauseTimeout","videoTimeToRestore","previousIsVideoActive","previousShouldPlayVideo","clearVideoStateTimeouts","useCallback","clearTimeout","attemptToPlayVideo","play","catch","name","warn","onClickDocument_1","document","message","attemptToPauseVideo","pause","onPause","onPlay","onPlaying","playing","resetStartTime","currentTime","keepVideoTimeWithinPlaybackRange","playbackRangeMaxTime","duration","playbackRangeMinTime","ended","isVideoStopped","isVideoLoadedEnoughToPlay","readyState","setTimeout","loading","useUnloadVideo","shouldUnloadVideo","load","useFormatVideoSrc","videoSrc","useMemo","formattedVideoSources","rawVideoSources","Array","isArray","numSources","source","hasPlaybackRangeStart","hasPlaybackRangeEnd","playbackRangeMediaFragmentIdentifier","push","src","type","useFormatVideoCaptions","videoCaptions","formattedVideoCaptions","rawVideoCaptions","numCaptions","captions","srcLang","label","kind","default","Boolean","expandToFillContainerStyle","position","width","height","top","bottom","left","right","containerMatchContentDimensionsStyle","display","containerSizingStyles","video","overlay","container","manual","pausedOverlayWrapperSizingStyles","videoSizingStyles","HoverVideoPlayer","_a","_b","_c","focused","_d","_e","_f","_g","_h","hoverOverlay","_j","pausedOverlay","_k","loadingOverlay","_l","_m","_o","_p","unloadVideoOnPaused","_q","_r","_s","_t","_u","_v","preload","_w","crossOrigin","_x","controls","_y","controlsList","_z","_0","_1","className","_2","style","_3","hoverOverlayWrapperClassName","_4","hoverOverlayWrapperStyle","_5","pausedOverlayWrapperClassName","_6","pausedOverlayWrapperStyle","_7","loadingOverlayWrapperClassName","_8","loadingOverlayWrapperStyle","_9","videoId","_10","videoClassName","_11","forwardedVideoRef","_12","videoStyle","_13","sizingMode","containerRef","useImperativeHandle","hasPausedOverlay","hasHoverOverlay","hasPlaybackRange","isPausedOverlayVisible","isLoadingOverlayVisibile","React","ref","zIndex","opacity","transition","pointerEvents","playsInline","objectFit","id","map","key","isDefault"],"sources":["/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/node_modules/tslib/tslib.es6.js","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/hooks/useSetAdditionalAttributesOnVideo.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/hooks/useIsHoveringOverVideo.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/constants/OverlayState.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/hooks/useManageVideoPlayback.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/hooks/useUnloadVideo.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/hooks/useFormatVideoSrc.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/hooks/useFormatVideoCaptions.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/component/HoverVideoPlayer.styles.ts","/Users/fvckimba/Desktop/dev/kove-website/node_modules/react-hover-video-player/src/component/HoverVideoPlayer.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import React, { useEffect } from 'react';\n\n/**\n * Hook handles manually setting some additional attributes on the video that\n * can't be set directly via attributes on the element.\n *\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\n * @param {bool} muted - Whether the video should be muted\n * @param {number} volume - The volume level that the video's audio should be set to\n * @param {bool} disableRemotePlayback - Whether we want to disable showing controls to cast the video\n * @param {bool} disablePictureInPicture - Whether we want to disable showing controls to play the video in picture-in-picture mode\n */\nexport default function useSetAdditionalAttributesOnVideo(\n  videoRef: React.RefObject<HTMLVideoElement>,\n  muted: boolean,\n  volume: number,\n  disableRemotePlayback: boolean,\n  disablePictureInPicture: boolean\n): void {\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    videoElement.muted = muted;\n    // Set the video's volume to match the `volume` prop\n    // Note that this will have no effect if the `muted` prop is set to true\n    videoElement.volume = volume;\n  }, [videoRef, muted, volume]);\n\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    // React does not support directly setting disableRemotePlayback or disablePictureInPicture directly\n    // via the video element's props, so we have to manually set them in an effect\n    videoElement.disableRemotePlayback = disableRemotePlayback;\n    videoElement.disablePictureInPicture = disablePictureInPicture;\n  }, [videoRef, disablePictureInPicture, disableRemotePlayback]);\n}\n","import { useEffect, useRef, useState } from 'react';\n\nimport { HoverTarget } from '../HoverVideoPlayer.types';\n\n/**\n * Hook adds event listeners to the hover target and returns whether the user is currently hovering over it or not.\n *\n * @param {HoverTarget} hoverTarget - Ref, function, or Node for the element that we should apply our hover event listeners to.\n *                                      If the user did not specify one with the hoverTarget prop, we will fall back to use\n *                                      the hover player's container div element.\n * @param {bool} disableDefaultEventHandling - Whether our default event handling should be disabled.\n * @param {func} onHoverStart - Callback fired when the user starts hovering on the player's hover target\n * @param {func} onHoverEnd - Callback fired when the user stops hovering on the player's hover target\n *\n * @returns {bool}  Whether the user is currently hovering over the player's hover target\n */\nexport default function useIsHoveringOverVideo(\n  hoverTarget: HoverTarget,\n  disableDefaultEventHandling: boolean,\n  onHoverStartCallback: () => void,\n  onHoverEndCallback: () => void\n): boolean {\n  // Keep track of whether the user is hovering over the video and it should therefore be playing or not\n  const [isHoveringOverVideo, setIsHoveringOverVideo] = useState(false);\n  const previousIsHoveringOverVideoRef = useRef(isHoveringOverVideo);\n\n  useEffect(() => {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined;\n\n    // Get the element that we should add our hover event listeners to\n    let hoverEventTargetElement: Node;\n\n    // If the `hoverTarget` prop was provided, it could be a function, a DOM element, or a React ref, so\n    // figure out which one it is and get the hover target element out of it accordingly\n    if (typeof hoverTarget === 'function') {\n      hoverEventTargetElement = hoverTarget();\n    } else if (hoverTarget instanceof Node) {\n      hoverEventTargetElement = hoverTarget;\n    } else if (hoverTarget.current) {\n      hoverEventTargetElement = hoverTarget.current;\n    }\n\n    // If we weren't able to get a valid hover target to attach event listeners to, return early\n    if (!hoverEventTargetElement || !hoverEventTargetElement.addEventListener) {\n      console.error(\n        'HoverVideoPlayer was unable to add event listeners to a hover target. Please check your usage of the `hoverTarget` prop.'\n      );\n      return undefined;\n    }\n\n    // Add the event listeners\n    const onHoverStart = () => setIsHoveringOverVideo(true);\n    const onHoverEnd = () => setIsHoveringOverVideo(false);\n\n    // Mouse events\n    hoverEventTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverEventTargetElement.addEventListener('mouseleave', onHoverEnd);\n\n    // Focus/blur\n    hoverEventTargetElement.addEventListener('focus', onHoverStart);\n    hoverEventTargetElement.addEventListener('blur', onHoverEnd);\n\n    // Touch events\n    const touchStartListenerOptions = { passive: true };\n\n    hoverEventTargetElement.addEventListener(\n      'touchstart',\n      onHoverStart,\n      touchStartListenerOptions\n    );\n    // Event listener pauses the video when the user touches somewhere outside of the player\n    const onWindowTouchStart = (event: TouchEvent) => {\n      if (\n        !(event.target instanceof Node) ||\n        !hoverEventTargetElement.contains(event.target)\n      ) {\n        onHoverEnd();\n      }\n    };\n\n    window.addEventListener(\n      'touchstart',\n      onWindowTouchStart,\n      touchStartListenerOptions\n    );\n\n    // Return a cleanup function that removes all event listeners\n    return () => {\n      hoverEventTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverEventTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverEventTargetElement.removeEventListener('focus', onHoverStart);\n      hoverEventTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverEventTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTarget]);\n\n  // Effect fires hover callbacks as isHoveringOverVideo changes\n  useEffect(() => {\n    if (previousIsHoveringOverVideoRef.current === isHoveringOverVideo) return;\n    previousIsHoveringOverVideoRef.current = isHoveringOverVideo;\n\n    if (isHoveringOverVideo && onHoverStartCallback != null) {\n      onHoverStartCallback();\n    } else if (!isHoveringOverVideo && onHoverEndCallback != null) {\n      onHoverEndCallback();\n    }\n  }, [isHoveringOverVideo, onHoverEndCallback, onHoverStartCallback]);\n\n  return isHoveringOverVideo;\n}\n","// Enumerates states that the hover player's overlay can be in\nexport enum OverlayState {\n  // Only the paused overlay is visible, if provided\n  paused = 'paused',\n  // Both the paused and loading overlays are visible, if provided\n  loading = 'loading',\n  // No overlays are visible\n  playing = 'playing',\n}\n","import React, { useEffect, useState, useRef, useCallback } from 'react';\n\nimport { OverlayState } from '../constants/OverlayState';\n\ninterface MutableVideoState {\n  isPlayAttemptInProgress: boolean;\n  pauseTimeout: number;\n  loadingStateTimeout: number;\n  videoTimeToRestore: number;\n  previousIsVideoActive: boolean;\n  previousShouldPlayVideo: boolean;\n}\n\n/**\n * Hook manages safely transitioning video playback between\n * a playing or paused state, depending on the value of shouldPlayVideo\n *\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\n * @param {bool} shouldPlayVideo - Whether the video should currently be playing or not\n * @param {number} playbackRangeStart - The start time of the playback range that the video must be kept within\n * @param {number} playbackRangeEnd - The end time of the playback range that the video must be kept within\n * @param {bool} loop - Whether the video should loop when it reaches the end of its playback range or not\n *                        If a playback range is set, the native `loop` video attribute will not work, so we have to\n *                        manually implement this behavior ourselves.\n * @param {bool} restartOnPaused - Whether the video should be reset to the start when paused\n * @param {bool} shouldWaitForOverlayTransitionBeforePausing - Whether the player has an overlay which we should wait to fade back in before we pause the video\n * @param {bool} hasLoadingOverlay - Whether the player has an overlay to display when loading\n * @param {number} overlayTransitionDuration - How long it should take for overlays to fade in/out; this influences how long we should wait\n *                                              after the user stops hovering before fully pausing the video since the paused overlay needs time to fade in.\n * @param {number} loadingStateTimeout - How long to wait after starting a play attempt to fade in the loading overlay\n *\n * @returns {[OverlayState, bool]} An array with the current overlay state in the first position and whether the video player is active in the second positions\n */\nexport default function useManageVideoPlayback(\n  videoRef: React.RefObject<HTMLVideoElement>,\n  shouldPlayVideo: boolean,\n  playbackRangeStart: number,\n  playbackRangeEnd: number,\n  loop: boolean,\n  restartOnPaused: boolean,\n  shouldWaitForOverlayTransitionBeforePausing: boolean,\n  hasLoadingOverlay: boolean,\n  overlayTransitionDuration: number,\n  loadingStateTimeout: number\n): [OverlayState, boolean] {\n  // Keep track of how the paused and loading overlays should be displayed\n  const [overlayState, setOverlayState] = useState<OverlayState>(\n    OverlayState.paused\n  );\n  // Keep track of whether the video is currently playing or attempting to play\n  const [isVideoLoadingOrPlaying, setIsVideoLoadingOrPlaying] =\n    useState<boolean>(false);\n\n  // Keep track of when the video is \"active\", meaning it is in one of the following states:\n  // 1. The user is hovering over the video but it is still loading\n  // 2. The user is hovering over the video and it is playing\n  // 3. The user is no longer hovering over the video but it is still transitioning back into a paused state\n  //\n  // This helps us keep track of when the player is truly done with the video so we can perform\n  // cleanup such as resetting the time to the start or unloading the video\n  const isVideoActive = shouldPlayVideo || isVideoLoadingOrPlaying;\n\n  // Keep a ref for all variables related to the video's playback state\n  // which we need to persist between renders and manage asynchronously\n  // but shouldn't trigger re-renders when updated\n  const mutableVideoState = useRef<MutableVideoState>(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      // Whether there is a play promise in progress which we should avoid interrupting\n      // with calls to video.pause() or video.load()\n      isPlayAttemptInProgress: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: playbackRangeStart || 0,\n      // Keep refs to previous values for some states so we can avoid running effects for\n      // changes in values we don't care about\n      previousIsVideoActive: false,\n      previousShouldPlayVideo: false,\n    };\n  }\n\n  // Cancel any pending timeouts to pause or show a loading state\n  const clearVideoStateTimeouts = useCallback(() => {\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n  }, []);\n\n  useEffect(\n    // On cleanup when the component is unmounting, clear any outstanding timeouts\n    () => () => clearVideoStateTimeouts(),\n    [clearVideoStateTimeouts]\n  );\n\n  // Method begins an attempt to play the video and updates state accordingly\n  const attemptToPlayVideo = useCallback(() => {\n    mutableVideoState.current.isPlayAttemptInProgress = true;\n\n    const videoElement = videoRef.current;\n\n    videoElement.play().catch((error: DOMException) => {\n      // Additional handling for when browsers block playback for unmuted videos.\n      // This is unfortunately necessary because most modern browsers do not allow playing videos with audio\n      //  until the user has \"interacted\" with the page by clicking somewhere at least once; mouseenter events\n      //  don't count.\n\n      // If the video isn't muted and playback failed with a `NotAllowedError`, this means the browser blocked\n      // playing the video because the user hasn't clicked anywhere on the page yet.\n      if (!videoElement.muted && error.name === 'NotAllowedError') {\n        console.warn(\n          'HoverVideoPlayer: Playback with sound was blocked by the browser. Attempting to play again with the video muted; audio will be restored if the user clicks on the page.'\n        );\n        // Mute the video and attempt to play again\n        videoElement.muted = true;\n        videoElement.play();\n\n        // When the user clicks on the document, unmute the video since we should now\n        // be free to play audio\n        const onClickDocument = () => {\n          videoElement.muted = false;\n\n          // Clean up the event listener so it is only fired once\n          document.removeEventListener('click', onClickDocument);\n        };\n        document.addEventListener('click', onClickDocument);\n      } else {\n        // Log any other playback errors with console.error\n        console.error(`HoverVideoPlayer: ${error.message}`);\n      }\n    });\n  }, [videoRef]);\n\n  // Method attempts to pause the video, if it is safe to do so without interrupting a pending play promise\n  const attemptToPauseVideo = useCallback(() => {\n    const videoElement = videoRef.current;\n\n    if (\n      !videoElement.paused &&\n      // If there is a play attempt in progress, the video can't be\n      //  safely paused right away without intnerrupting the play promise and throwing an error.\n      // In this case, we'll have to wait for the logic in the video's `onPlaying` event\n      // to immediately pause the video as soon as the play promise resolves\n      !mutableVideoState.current.isPlayAttemptInProgress\n    ) {\n      videoElement.pause();\n    }\n  }, [videoRef]);\n\n  // Effect adds a `play` and `pause` event listener to the video element to keep our state\n  // updated to reflect whether the video is currently playing or paused\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    const onPause = () => setIsVideoLoadingOrPlaying(false);\n    const onPlay = () => setIsVideoLoadingOrPlaying(true);\n    videoElement.addEventListener('pause', onPause);\n    videoElement.addEventListener('play', onPlay);\n\n    return () => {\n      videoElement.removeEventListener('pause', onPause);\n      videoElement.removeEventListener('play', onPlay);\n    };\n  }, [videoRef]);\n\n  // Effect adds a `playing` event listener to the video to update state to reflect when the video successfully starts playing\n  useEffect(() => {\n    const videoElement = videoRef.current;\n\n    // Listen for when the video actually finishes loading and starts playing\n    const onPlaying = () => {\n      // Ensure we cancel any pending loading state timeout\n      clearVideoStateTimeouts();\n\n      // The play attempt is now complete\n      mutableVideoState.current.isPlayAttemptInProgress = false;\n\n      if (shouldPlayVideo) {\n        // Hide the overlays to reveal the video now that it's playing\n        setOverlayState(OverlayState.playing);\n      } else {\n        // If the play attempt just succeeded but we no longer want to play the video,\n        // pause it immediately!\n        videoElement.pause();\n      }\n    };\n    videoElement.addEventListener('playing', onPlaying);\n\n    return () => {\n      videoElement.removeEventListener('playing', onPlaying);\n    };\n  }, [clearVideoStateTimeouts, shouldPlayVideo, videoRef]);\n\n  // When the video becomes inactive, effect resets it to the start if restartOnPaused is true and\n  // stores the video's current time so we can restore to it when we start playing the video again\n  useEffect(() => {\n    if (mutableVideoState.current.previousIsVideoActive === isVideoActive) {\n      return;\n    }\n    mutableVideoState.current.previousIsVideoActive = isVideoActive;\n\n    if (!isVideoActive) {\n      const videoElement = videoRef.current;\n\n      // Ensure we cancel any pending timeouts to pause or show a loading state\n      // since we are now officially paused\n      clearVideoStateTimeouts();\n\n      if (restartOnPaused) {\n        // Reset the video to the start since we're now paused\n        const resetStartTime = playbackRangeStart || 0;\n        videoElement.currentTime = resetStartTime;\n      }\n\n      // Hang onto the time that the video is currently at so we can\n      // restore it when we try to play again\n      // This is mainly helpful because the unloadVideoOnPaused prop will cause\n      // the video's currentTime to be cleared every time its sources are unloaded\n      // after pausing\n      mutableVideoState.current.videoTimeToRestore = videoElement.currentTime;\n    }\n  }, [\n    clearVideoStateTimeouts,\n    isVideoActive,\n    playbackRangeStart,\n    restartOnPaused,\n    videoRef,\n  ]);\n\n  // Effect starts an update loop while the video is playing\n  // to ensure the video stays within the bounds of its playback range\n  useEffect(() => {\n    if (\n      // If we don't have a playback range set, we don't need to do anything here\n      playbackRangeStart === null &&\n      playbackRangeEnd === null\n    )\n      return undefined;\n\n    const videoElement = videoRef.current;\n\n    // Checks the video's time to make sure it\n    // stays clamped inside the playback range\n    const keepVideoTimeWithinPlaybackRange = () => {\n      // Use playbackRangeEnd as our maximum time to play to, or default to the video's full duration\n      const playbackRangeMaxTime = playbackRangeEnd || videoElement.duration;\n      // Use playbackRangeStart as our minimum time to play from, or default to the very beginning of the video (0sƒ)\n      const playbackRangeMinTime = playbackRangeStart || 0;\n\n      if (videoElement.currentTime >= playbackRangeMaxTime) {\n        // If the video's current time has played past the maximum time in the playback range,\n        // determine how to handle keeping the video inside of the playback range\n        if (loop) {\n          // If the video should loop, jump it back to the start of the playback range again\n          videoElement.currentTime = playbackRangeMinTime;\n\n          // If the video is paused, start playing it again (when the video reaches the end\n          // of the playback range for the first time, most browsers will pause it)\n          if (shouldPlayVideo && (videoElement.paused || videoElement.ended)) {\n            attemptToPlayVideo();\n          }\n        } else {\n          // If we don't want to loop the video, just pause it\n          attemptToPauseVideo();\n\n          if (videoElement.currentTime > playbackRangeMaxTime) {\n            videoElement.currentTime = playbackRangeMaxTime;\n          }\n        }\n      } else if (videoElement.currentTime < playbackRangeMinTime) {\n        // If the video's current time has someone gotten before the playback range,\n        // clamp it to the lower end of the playback range\n        videoElement.currentTime = playbackRangeMinTime;\n      }\n    };\n\n    // Run one initial check to make sure the video is initially clamped within its playback range\n    keepVideoTimeWithinPlaybackRange();\n\n    // Add a timeupdate event listener to keep the video within its playback range\n    // as its time changes\n    videoElement.addEventListener(\n      'timeupdate',\n      keepVideoTimeWithinPlaybackRange\n    );\n\n    // Remove the event listener on cleanup\n    return () =>\n      videoElement.removeEventListener(\n        'timeupdate',\n        keepVideoTimeWithinPlaybackRange\n      );\n  }, [\n    attemptToPauseVideo,\n    attemptToPlayVideo,\n    loop,\n    playbackRangeEnd,\n    playbackRangeStart,\n    shouldPlayVideo,\n    videoRef,\n  ]);\n\n  // Effect attempts to play or pause the video as shouldPlayVideo changes\n  useEffect(() => {\n    // Only run the effect when shouldPlayVideo changes\n    if (mutableVideoState.current.previousShouldPlayVideo === shouldPlayVideo) {\n      return;\n    }\n    mutableVideoState.current.previousShouldPlayVideo = shouldPlayVideo;\n\n    // Clear any outstanding timeouts since our playback state is changing\n    clearVideoStateTimeouts();\n\n    const videoElement = videoRef.current;\n\n    // The video is stopped if it is paused or ended\n    const isVideoStopped = videoElement.paused || videoElement.ended;\n\n    // If shouldPlayVideo is true, attempt to start playing the video\n    if (shouldPlayVideo) {\n      // readyState 3 is HAVE_FUTURE_DATA, meaning the video has loaded enough data that it can play\n      const isVideoLoadedEnoughToPlay = videoElement.readyState >= 3;\n\n      // If the video is stopped or still loading and we have a loading overlay,\n      // set a timeout to display the overlay if the video doesn't finish loading\n      // after a certain amount of time\n      if ((isVideoStopped || !isVideoLoadedEnoughToPlay) && hasLoadingOverlay) {\n        // If we have a loading overlay, set a timeout to start showing it if the video doesn't start playing\n        // before the loading state timeout has elapsed\n        mutableVideoState.current.loadingStateTimeout = window.setTimeout(\n          () => {\n            // If this timeout wasn't cancelled, we're still trying to play the video\n            // and it's still loading, so fade in the loading overlay\n            setOverlayState(OverlayState.loading);\n          },\n          loadingStateTimeout\n        );\n      }\n\n      // If the video is fully stopped, we need to attempt to start it by calling play()\n      if (isVideoStopped) {\n        // Ensure we're at the correct time to start playing from\n        videoElement.currentTime = mutableVideoState.current.videoTimeToRestore;\n\n        // Start attempting to play\n        attemptToPlayVideo();\n      } else if (isVideoLoadedEnoughToPlay) {\n        // If the video isn't stopped and is loaded enough to play. it's already playing,\n        // so ensure the overlays are hidden to reflect that!\n        setOverlayState(OverlayState.playing);\n      }\n    }\n    // Otherwise if shouldPlayVideo is false, go through the process necessary to pause the video\n    else {\n      // Start fading the paused overlay back in\n      setOverlayState(OverlayState.paused);\n\n      if (\n        shouldWaitForOverlayTransitionBeforePausing &&\n        overlayTransitionDuration\n      ) {\n        // If we have a paused/hover overlay, set a timeout with a duration of the overlay's fade\n        // transition since we want to keep the video playing until the overlay has fully\n        // faded in and hidden it.\n        mutableVideoState.current.pauseTimeout = window.setTimeout(\n          attemptToPauseVideo,\n          overlayTransitionDuration\n        );\n      } else {\n        // If we don't have an overlay transition to wait on, pause right away!\n        attemptToPauseVideo();\n      }\n    }\n  }, [\n    attemptToPauseVideo,\n    attemptToPlayVideo,\n    clearVideoStateTimeouts,\n    hasLoadingOverlay,\n    shouldWaitForOverlayTransitionBeforePausing,\n    loadingStateTimeout,\n    overlayTransitionDuration,\n    shouldPlayVideo,\n    videoRef,\n  ]);\n\n  return [overlayState, isVideoActive];\n}\n","import React, { useEffect } from 'react';\n\n/**\n * Hook unloads the video when it is paused, if the unloadVideoOnPaused prop was set to true\n *\n * @param {React.RefObject<HTMLVideoElement>} videoRef - Ref to the video element\n * @param {bool} shouldUnloadVideo - Whether we should unload the video's sources\n */\nexport default function useUnloadVideo(\n  videoRef: React.RefObject<HTMLVideoElement>,\n  shouldUnloadVideo: boolean\n): void {\n  // Effect ensures the video element fully unloads after its <source> tags were removed\n  useEffect(() => {\n    if (shouldUnloadVideo) {\n      // Perform a manual load to unload the video's current source\n      const videoElement = videoRef.current;\n      videoElement.load();\n    }\n  }, [shouldUnloadVideo, videoRef]);\n}\n","import { useMemo } from 'react';\nimport { VideoSource, VideoSrcProp } from '../HoverVideoPlayer.types';\n\n/**\n * @function  formatVideoSrc\n *\n * Hook takes the videoSrc prop and formats it as a standardized array of VideoSource objects which can be used to render\n * <source> elements for the video\n *\n * @param {VideoSrcProp}  videoSrc - Source(s) to format into VideoSource objects so they can be added to the video player.\n * @param {number}  playbackRangeStart - The earliest time in seconds that we should start loading the video from.\n *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only\n *                                        load the video starting from this time.\n *                                        If not provided, we will load from the start of the video.\n * @param {number}  playbackRangeEnd - The maximum time in seconds that we should load the video to.\n *                                        This will be enforced by using a #t media fragment identifier to tell the browser to only\n *                                        load the video up to this time.\n *                                        If not provided, we will load to the end of the video.\n *\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\n */\nexport default function useFormatVideoSrc(\n  videoSrc: VideoSrcProp,\n  playbackRangeStart?: number,\n  playbackRangeEnd?: number\n): VideoSource[] {\n  return useMemo(() => {\n    const formattedVideoSources = [];\n\n    if (videoSrc == null) {\n      // A videoSrc value is required in order to make the video player work\n      console.error(\n        \"Error: 'videoSrc' prop is required for HoverVideoPlayer component\"\n      );\n    } else {\n      // Make sure we can treat the videoSrc value as an array\n      const rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc];\n\n      // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n      for (\n        let i = 0, numSources = rawVideoSources.length;\n        i < numSources;\n        i += 1\n      ) {\n        const source = rawVideoSources[i];\n\n        const hasPlaybackRangeStart = playbackRangeStart !== null;\n        const hasPlaybackRangeEnd = playbackRangeEnd !== null;\n\n        // Construct a media fragment identifier string to append to the video's URL to ensure\n        // we only load the portion of the video that we need for the provided playback range\n        // (see here for more details: https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery#specifying_playback_range)\n        const playbackRangeMediaFragmentIdentifier =\n          hasPlaybackRangeStart || hasPlaybackRangeEnd\n            ? // If we have a playback range defined, construct a #t media fragment identifier string\n              // This identifier follows the format `#t=[starttime][,endtime]` and will tell the browser to only load the video file\n              // within this defined time range.\n              // This helps save us from loading some unneeded data when we only need whatever is within the playback range!\n              `#t=${hasPlaybackRangeStart ? playbackRangeStart : ''}${\n                hasPlaybackRangeEnd ? `,${playbackRangeEnd}` : ''\n              }`\n            : '';\n\n        if (typeof source === 'string') {\n          // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n          formattedVideoSources.push({\n            src: `${source}${playbackRangeMediaFragmentIdentifier}`,\n          });\n        } else if (source && source.src) {\n          // If the source is an object with an src, just add it to the array\n          formattedVideoSources.push({\n            src: `${source.src}${playbackRangeMediaFragmentIdentifier}`,\n            type: source.type,\n          });\n        } else {\n          // Log an error if one of the videoSrc values is invalid\n          console.error(\n            \"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\",\n            source\n          );\n        }\n      }\n    }\n\n    return formattedVideoSources;\n  }, [videoSrc, playbackRangeStart, playbackRangeEnd]);\n}\n","import { useMemo } from 'react';\nimport {\n  VideoCaptionsTrack,\n  VideoCaptionsProp,\n} from '../HoverVideoPlayer.types';\n\n/**\n * Hook takes the videoCaptions prop and formats it as a standardized array of VideoCaptionsTrack objects which can be used to render\n * <track> elements for the video\n *\n * @param {VideoCaptionsProp} videoCaptions - Captions track(s) to use for the video player for accessibility.\n *\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\n */\nexport default function useFormatVideoCaptions(\n  videoCaptions: VideoCaptionsProp\n): VideoCaptionsTrack[] {\n  return useMemo(() => {\n    const formattedVideoCaptions = [];\n\n    // If captions were provided, format them for use for the video\n    if (videoCaptions != null) {\n      // Make sure we can treat the videoCaptions value as an array\n      const rawVideoCaptions = Array.isArray(videoCaptions)\n        ? videoCaptions\n        : [videoCaptions];\n\n      // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n      // objects that can be used to render caption tracks for the video\n      for (\n        let i = 0, numCaptions = rawVideoCaptions.length;\n        i < numCaptions;\n        i += 1\n      ) {\n        const captions = rawVideoCaptions[i];\n\n        if (captions && captions.src) {\n          formattedVideoCaptions.push({\n            src: captions.src,\n            srcLang: captions.srcLang,\n            label: captions.label,\n            kind: captions.kind || 'captions',\n            default: Boolean(captions.default),\n          });\n        } else {\n          // Log an error if one of the videoCaptions values is invalid\n          console.error(\n            \"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\",\n            captions\n          );\n        }\n      }\n    }\n\n    return formattedVideoCaptions;\n  }, [videoCaptions]);\n}\n","import React from 'react';\n\ninterface SizingModeStyle {\n  video: React.CSSProperties;\n  overlay: React.CSSProperties;\n  container: React.CSSProperties;\n  manual: React.CSSProperties;\n}\n\n// CSS styles to make some contents in the player expand to fill the container\nexport const expandToFillContainerStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n};\n\nconst containerMatchContentDimensionsStyle: React.CSSProperties = {\n  display: 'inline-block',\n};\n\nexport const containerSizingStyles: SizingModeStyle = {\n  video: containerMatchContentDimensionsStyle,\n  overlay: containerMatchContentDimensionsStyle,\n  container: null,\n  manual: null,\n};\n\n// Styles to apply to the paused overlay wrapper for each sizing mode\nexport const pausedOverlayWrapperSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so make the overlay\n  // expand to cover the player's container element\n  video: expandToFillContainerStyle,\n  // Sizing should be based on the paused overlay, so set position: relative\n  // to make it occupy space in the document flow\n  overlay: {\n    position: 'relative',\n  },\n  // Sizing should be based on the player's container element, so make the overlay\n  // expand to cover it\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the overlay\n  manual: null,\n};\n\n// Styles to apply to the video element for each sizing mode\nexport const videoSizingStyles: SizingModeStyle = {\n  // Sizing should be based on the video element, so set display: block\n  // to make sure it occupies space in the document flow\n  video: {\n    display: 'block',\n    // Ensure the video is sized relative to the container's width\n    // rather than the video asset's native width\n    width: '100%',\n  },\n  // Make the video element expand to cover the container if we're sizing\n  // based on the overlay or container\n  overlay: expandToFillContainerStyle,\n  container: expandToFillContainerStyle,\n  // Don't apply any preset styling to the video\n  manual: null,\n};\n","import React, { useRef, useImperativeHandle } from 'react';\n\nimport useSetAdditionalAttributesOnVideo from '../hooks/useSetAdditionalAttributesOnVideo';\nimport useIsHoveringOverVideo from '../hooks/useIsHoveringOverVideo';\nimport useManageVideoPlayback from '../hooks/useManageVideoPlayback';\nimport useUnloadVideo from '../hooks/useUnloadVideo';\nimport useFormatVideoSrc from '../hooks/useFormatVideoSrc';\nimport useFormatVideoCaptions from '../hooks/useFormatVideoCaptions';\n\nimport {\n  expandToFillContainerStyle,\n  containerSizingStyles,\n  pausedOverlayWrapperSizingStyles,\n  videoSizingStyles,\n} from './HoverVideoPlayer.styles';\nimport { OverlayState } from '../constants/OverlayState';\nimport { HoverVideoPlayerProps } from '../HoverVideoPlayer.types';\n\n/**\n * @component HoverVideoPlayer\n * @license MIT\n *\n * @param {HoverVideoPlayerProps} props\n */\nconst HoverVideoPlayer = ({\n  videoSrc,\n  videoCaptions = null,\n  focused = false,\n  disableDefaultEventHandling = false,\n  hoverTarget = null,\n  onHoverStart = null,\n  onHoverEnd = null,\n  hoverOverlay = null,\n  pausedOverlay = null,\n  loadingOverlay = null,\n  loadingStateTimeout = 200,\n  overlayTransitionDuration = 400,\n  restartOnPaused = false,\n  unloadVideoOnPaused = false,\n  playbackRangeStart = null,\n  playbackRangeEnd = null,\n  muted = true,\n  volume = 1,\n  loop = true,\n  preload = null,\n  crossOrigin = 'anonymous',\n  controls = false,\n  controlsList = null,\n  disableRemotePlayback = true,\n  disablePictureInPicture = true,\n  className = null,\n  style = null,\n  hoverOverlayWrapperClassName = null,\n  hoverOverlayWrapperStyle = null,\n  pausedOverlayWrapperClassName = null,\n  pausedOverlayWrapperStyle = null,\n  loadingOverlayWrapperClassName = null,\n  loadingOverlayWrapperStyle = null,\n  videoId = null,\n  videoClassName = null,\n  videoRef: forwardedVideoRef = null,\n  videoStyle = null,\n  sizingMode = 'video',\n}: HoverVideoPlayerProps): JSX.Element => {\n  // Element refs\n  const containerRef = useRef(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  // Forward out local videoRef along to the videoRef prop\n  useImperativeHandle(forwardedVideoRef, () => videoRef.current);\n\n  // Effect sets attributes on the video which can't be done via props\n  useSetAdditionalAttributesOnVideo(\n    videoRef,\n    muted,\n    volume,\n    disableRemotePlayback,\n    disablePictureInPicture\n  );\n\n  const isHoveringOverVideo = useIsHoveringOverVideo(\n    // If the hoverTarget prop wasn't provided, fall back to the component's container div\n    hoverTarget || containerRef,\n    disableDefaultEventHandling,\n    onHoverStart,\n    onHoverEnd\n  );\n\n  // We should attempt to play the video if the user is hovering over it or the `focused` override prop is enabled\n  const shouldPlayVideo = isHoveringOverVideo || focused;\n\n  const hasPausedOverlay = Boolean(pausedOverlay);\n  const hasHoverOverlay = Boolean(hoverOverlay);\n\n  // If we have a paused or hover overlay, the player should wait\n  // for the overlay(s) to finish transitioning back in before we\n  // pause the video\n  const shouldWaitForOverlayTransitionBeforePausing =\n    hasPausedOverlay || hasHoverOverlay;\n\n  const hasLoadingOverlay = Boolean(loadingOverlay);\n\n  // Effect handles transitioning the video between playing or paused states\n  // depending on the current value for `shouldPlayVideo`\n  const [overlayState, isVideoActive] = useManageVideoPlayback(\n    videoRef,\n    shouldPlayVideo,\n    playbackRangeStart,\n    playbackRangeEnd,\n    loop,\n    restartOnPaused,\n    shouldWaitForOverlayTransitionBeforePausing,\n    hasLoadingOverlay,\n    overlayTransitionDuration,\n    loadingStateTimeout\n  );\n\n  // If the video's sources should be unloaded when it's paused and the video is not currently active, we can unload the video's sources.\n  // We will remove the video's <source> tags in this render and then call video.load() in an effect to\n  // fully unload the video\n  const shouldUnloadVideo = unloadVideoOnPaused && !isVideoActive;\n  useUnloadVideo(videoRef, shouldUnloadVideo);\n\n  // Parse the sources and captions into formatted arrays that we can use to\n  // render <source> and <track> elements for the video\n  const formattedVideoSources = useFormatVideoSrc(\n    videoSrc,\n    playbackRangeStart,\n    playbackRangeEnd\n  );\n  const formattedVideoCaptions = useFormatVideoCaptions(videoCaptions);\n\n  const hasPlaybackRange =\n    playbackRangeStart !== null || playbackRangeEnd !== null;\n\n  // Show the paused overlay if the overlay state is either \"paused\" OR \"loading\"; if\n  // \"loading\", the loading overlay will be displayed on top of the paused overlay\n  const isPausedOverlayVisible = overlayState !== OverlayState.playing;\n  // Show the loading overlay only if the overlay state is specifically \"loading\"\n  const isLoadingOverlayVisibile = overlayState === OverlayState.loading;\n\n  return (\n    <div\n      data-testid=\"hover-video-player-container\"\n      ref={containerRef}\n      className={className}\n      style={{\n        ...containerSizingStyles[sizingMode],\n        position: 'relative',\n        ...style,\n      }}\n    >\n      {hasPausedOverlay ? (\n        <div\n          style={{\n            ...pausedOverlayWrapperSizingStyles[sizingMode],\n            zIndex: 1,\n            opacity: isPausedOverlayVisible ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the paused overlay when it's hidden\n            pointerEvents: isPausedOverlayVisible ? 'auto' : 'none',\n            ...pausedOverlayWrapperStyle,\n          }}\n          className={pausedOverlayWrapperClassName}\n          data-testid=\"paused-overlay-wrapper\"\n        >\n          {pausedOverlay}\n        </div>\n      ) : null}\n      {hasLoadingOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 2,\n            opacity: isLoadingOverlayVisibile ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the loading overlay when it's hidden\n            pointerEvents: isLoadingOverlayVisibile ? 'auto' : 'none',\n            ...loadingOverlayWrapperStyle,\n          }}\n          className={loadingOverlayWrapperClassName}\n          data-testid=\"loading-overlay-wrapper\"\n        >\n          {loadingOverlay}\n        </div>\n      ) : null}\n      {hasHoverOverlay ? (\n        <div\n          style={{\n            ...expandToFillContainerStyle,\n            zIndex: 3,\n            // Show the hover overlay when the player is hovered/playing\n            opacity: shouldPlayVideo ? 1 : 0,\n            transition: `opacity ${overlayTransitionDuration}ms`,\n            // Disable pointer events on the hover overlay when it's hidden\n            pointerEvents: shouldPlayVideo ? 'auto' : 'none',\n            ...hoverOverlayWrapperStyle,\n          }}\n          className={hoverOverlayWrapperClassName}\n          data-testid=\"hover-overlay-wrapper\"\n        >\n          {hoverOverlay}\n        </div>\n      ) : null}\n      {/* eslint-disable-next-line jsx-a11y/media-has-caption */}\n      <video\n        // If a playback range is set, the loop attribute will not work correctly so there's no point in setting it here;\n        // in that case, we will manually implement this behavior\n        loop={loop && !hasPlaybackRange}\n        playsInline\n        preload={preload}\n        crossOrigin={crossOrigin}\n        ref={videoRef}\n        style={{\n          ...videoSizingStyles[sizingMode],\n          objectFit: 'cover',\n          ...videoStyle,\n        }}\n        controls={controls}\n        controlsList={controlsList}\n        className={videoClassName}\n        id={videoId}\n        data-testid=\"video-element\"\n      >\n        {!shouldUnloadVideo &&\n          // Only render sources for the video if it is not unloaded\n          formattedVideoSources.map(({ src, type }) => (\n            <source key={src} src={src} type={type} />\n          ))}\n        {formattedVideoCaptions.map(\n          ({ src, srcLang, label, kind, default: isDefault }) => (\n            <track\n              key={src}\n              kind={kind}\n              src={src}\n              srcLang={srcLang}\n              label={label}\n              default={isDefault}\n            />\n          )\n        )}\n      </video>\n    </div>\n  );\n};\n\nexport default HoverVideoPlayer;\n"]},"metadata":{},"sourceType":"module"}